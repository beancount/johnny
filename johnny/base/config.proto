// -*- mode: protobuf -*-
// Configuration for Johnny.
//
// This schema is designed for input to the application that contains account
// configuration setups and manual clusterings for trades (it is not always
// possible to split logical trades correctly automatically in the same
// account).
//
//   Copyright (C) 2021  Martin Blais
//   License: GNU GPLv2

syntax = "proto2";

package johnny;

// Configuration for returns script.
message Config {
  // Input configuration.
  optional Inputs input = 1;

  // Output configuration.
  optional Outputs output = 2;

  // Mapping of futures options months to their corresponding underlying options
  // months. This is a temporary mapping we use until we code up the rules from
  // the CME contracts.
  optional FutOptMonthMapping futures_option_month_mapping = 3;

  // A list of manually disambiguated trades and their annotations.
  repeated Chain chains = 4;
}

// Configuration for inputs to be imported.
message Inputs {
  // A list of account sources to pull data from.
  repeated Account accounts = 1;

  // TODO(blais): Add a field for the Ledger to be processed to exclude a set of
  // order ids.
  // optional string ledger = 2;
}

// Configuration for outputs and databases.
message Outputs {
  // A database file to contain the processed and normalized transactions.
  optional string imported_filename = 1;
}

// This is a mapping of (option-product-code, month-code) to
// (futures-product-code, month-code). Options are offered on a monthly basis,
// but the underlying futures contract isn't necessarily offered for every month
// (depends on seasonality sometimes), so the underlying is sometimes for the
// same month (and the options expire a few days ahead of the futures) or for the
// subsequent month (in which case multiple months are applicable to the same
// underlying).
//
// CME has definitions on this, like this: "/SI: Monthly contracts listed for 3
// consecutive months and any Jan, Mar, May, and Sep in the nearest 23 months and
// any Jul and Dec in the nearest 60 months."
// https://www.cmegroup.com/trading/metals/precious/silver_contractSpecs_options.html
//
// We need to eventually encode all those rules as logic, as some input files
// (notably, from TOS) sometimes only produce the options code and in order to
// produce a normalized symbol we need both.
message FutOptMonthMapping {
  message Item {
    optional string option_product = 1;
    optional string option_month = 2;
    optional string future_product = 3;
    optional string future_month = 4;
  };
  repeated Item months = 1;
}

// The declaration of an account source. Only declared accounts are ingested.
// A declaration might look like this:
//   accounts {
//     nickname: "tasty"
//     logtype: TRANSACTIONS
//     module: "johnny.sources.tastyworks_csv.transactions"
//     source: "/home/joesmith/Downloads/*-AccountStatement.csv"
//   }
//
message Account {
  // A short and unique nickname or alias for the account. This should be
  // something you don't mind sharing publicly. The account name will me
  // replaced by this nickname for privacy reasons. If this isn't set, the
  // account number will be kept as is.
  optional string nickname = 1;

  // Importer type: transactions or positions.
  enum LogType {
    TRANSACTIONS = 1;
    POSITIONS = 2;
  }
  optional LogType logtype = 2;

  // Source module to use. This is a Python module-level path. This can be of
  // the form 'johnny.source.tastyworks_csv.transactions' for example.
  optional string module = 3;

  // A globbing pattern, URL, or other data telling the importer where to find
  // the files to import. If more than a single file matches, only the latest
  // file (by timestamp) will be imported. This is in essence, the configuration
  // across all possible sources, which are expected to be local files. In order
  // to contain dependencies, updating these local caches of remote transactions
  // logs should be done in separate programs using whichever APIs are
  // necessary; this library merely imports them into a single normalized
  // database.
  optional string source = 4;

  // A filename telling the importer where to find a CSV file with the initial
  // positions at the beginning of the transactions log. This file must contain
  // the following columns:
  //
  // * `transaction_id`: A unique transaction id for that account.
  // * `datetime`: The date at which to open the position
  // * `symbol`: The name of the symbol, including future and equity options.
  // * `instruction`: 'BUY' or 'SELL'
  // * `quantity`: Absolute number of units.
  // * `cost`: The total cost of that position (not per-unit).
  //
  // Other columns, if present, will be ignored. If this is provided, the import
  // will create these positions at the front of the transactions log history
  // import.
  optional string initial = 5;
}

// The status of a chain. This is produced in the output configuration after an
// import, and is intended for the user to review and update on a chain. This is
// essentially the market which allows you to confirm the current state of a
// chain's definition, and whether it is use in the algorithm as input.
//
// A chain begins its life as AUTO, automatically identified and produced by the
// heuristics. From there, it may be manually moved to PENDING, especially if
// some merging of chains needs to occur (e.g. in a pairs or cross-account
// trade). When the chain is complete, it can be marked FINAL by the user (in
// which case it will never change). Previously automatically identified chains
// that become invalid due to changes in the input and/or database are saved as
// IGNORE in order to avoid losing their contents (you should delete them
// manually).
enum ChainStatus {
  // Automatically identified and created chain. Those chain information will
  // not be read by the software, not be used at all in creating the chains.
  // They will be recreated from scratch automatically on a further run. They
  // are effectively ignored from the input, and are produced in order for you
  // to inspect them and upgrade their status to PENDING or FINAL. If the
  // algorithm changes, the definitions of those trades may change, e.g., they
  // could be split.
  AUTO = 1;

  // Automatically identified, created, and closed chain. The chain is "closed"
  // in that the resulting inventory has no residual position (all opened
  // positions in the chain have been closed). Those should be verified and
  // marked FINAL manually, or marked PENDING if it is desired for the chain to
  // be extended further.
  CLOSED = 2;

  // An active chain, which has been manually verified by the user but which
  // still needs to be matched against further trades. The algorithm will read
  // and create those chains, but also match new transactions against them, as
  // for automatic chains, so they can keep evolving over time. Use this in
  // order to initialize complex trades that may not otherwise be initialized
  // automatically, e.g. for pairs trades, or cross-account trades, or trades
  // that were legged in over multiple expirations and which may not be
  // identified automatically correctly.
  PENDING = 3;

  // An automatically finalized chain. Those are automatically pulling out the
  // corresponding transactions and never matched against any other transaction
  // rows in the log. Make your chain final when it has been completed and need
  // never be add or removed any more trades. Those chains should always be
  // completed matches, that is, all the opened positions should be closed by
  // the end of the chain. (The software may verify this invariant.)
  FINAL = 4;

  // For residual automatic chains that were read in the input but which aren't
  // identified by the algorithm anymore. We use the IGNORE type for those
  // chains which we want to keep in the output (we don't want to automatically
  // throw away this work) but which the algorithm believes aren't valid trades
  // anymore. This is essentially residual data you might salvage (if it was
  // useful and for some reason that chain name has changed, or if it has been
  // rendered not valid anymore - due to different chain identification after
  // more transactions were inserted in the log). You should be removing those
  // manually from your input file after review.
  IGNORE = 5;
}

// A trade chain.
message Chain {
  // The chain id of a trade. This is a unique string computed in the front end.
  optional string chain_id = 1;

  // Status of the chain. If not set, this is equivalent to AUTO.
  optional ChainStatus status = 2;

  // User-associated trade group or line of business. This can be used to split
  // up your trades in different groups, e.g. "MemeStocks", "ShortPremium",
  // "LongStock".
  optional string trade_type = 3;

  // Initial strategy used, e.g. "Strangle", "BrokenWingButterfly", etc. The
  // software may attempt to set a value for this, but you can override it in
  // the configuration file.
  optional string strategy = 4;

  // User-provided description. Free-form, may span multiple lines (include
  // newlines).
  optional string comment = 5;

  // If this is present, an explicit list of transaction ids that are part of
  // the trade. All the rows matching these transactions will be automatically
  // removed from the table and extracted as a unique chain. Make sure that
  // matches without these trades can resolve.
  repeated string transaction_ids = 6;

  // Fields for `transaction_ids` but which were filled automatically. Remove
  // the `auto_` prefix in order to make these permanent.
  repeated string auto_ids = 8;
}

// Declaration of asset vs. asset-class mapping.
message Asset {
  // Normalized instrument name.
  optional string instrument = 1;

  // Corresponding asset class, e.g. "EquityIndex", "Metals", "Rates", "Ags",
  // "Currencies", "Energy".
  optional string class = 2;

  // Factor. This is typically a sub-category of asset class. For example, asset
  // class would be "Metals", and factor might be "Copper" for FCX, COPX and
  // /HG.
  optional string factor = 3;
}
